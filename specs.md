Here’s a **buildable spec** for an **initial warehouse robot simulation** that takes: **map input, item catalog + placement, order distribution, and “order puts” (putaway/replen)** — and produces **throughput + congestion + utilization** metrics. This is intentionally scoped to be the *minimum* that still answers real questions.

---

# 0. Goal

Create a simulator that can answer:

* How many robots do we need for X orders/hour?
* Where are the bottlenecks (aisles, intersections, stations)?
* What batching / dispatch policies improve throughput?
* How do putaway/replen jobs affect picking SLAs?

Output should include:

* KPIs over time
* event logs for debugging
* optional “replay” traces for visualization later

---

# 1. Core Entities

## Warehouse topology

* **Nodes / edges** (graph) or **grid cells** (grid). Start with **graph** for flexibility.
* **Zones** (optional): group of nodes (fast lane, storage zone A, etc.)

## Storage

* **Rack**: positioned at a node (or covers a set of nodes)
* **Levels**: `L0..Ln` (multi-level)
* **Bins / slots**: location addressable as `(rack_id, level, bin)`

## Items

* `sku_id`, `volume`, `weight` (optional), handling constraints (optional)
* **Item placement**: mapping SKU → set of storage slots (with quantity)

## Stations

* **Pick stations**: where robots deliver items for orders
* **Drop stations**: where robots drop items (could be same as pick)
* Each station has:

  * `service_rate` (items/minute or totes/minute)
  * `queue_capacity`
  * `concurrency` (number of operators/ports)

## Robots

* `robot_id`
* `max_payload`
* kinematics: `max_speed`, `accel` (optional)
* `battery_capacity`, `charge_rate`, `min_soc`
* current state: position node, load, task queue

---

# 2. Jobs (Work Types)

Model jobs as sequences of **atomic actions**.

### Picking job (order fulfillment)

* `Acquire SKU` at storage slot
* `Transport` to station
* `Station service` (time at station)
* Optional: `Return tote` / `Drop empty` etc.

### Putaway / replen job (“order puts”)

Two modes:

1. **Inbound putaway**: source = inbound dock station → destination = storage slot
2. **Replen**: source = reserve storage → destination = pick-face slot

Atomic actions:

* `Pickup` at source location
* `Transport`
* `Drop` at destination
* Optional: `Scan/confirm time`

---

# 3. Inputs (Simulation Configuration)

Use a single `scenario.yaml` (or JSON) referencing other files.

## 3.1 Map input

**Option A (recommended): Graph JSON**

```json
{
  "nodes": [{"id":"N1","x":0,"y":0,"type":"aisle"}],
  "edges": [{"from":"N1","to":"N2","length_m":2.0,"bidirectional":true}],
  "constraints": {
    "one_way_edges": [],
    "blocked_nodes": [],
    "blocked_edges": []
  }
}
```

**Node types** (extensible):

* `aisle`, `intersection`, `station_pick`, `station_drop`, `charger`, `rack_access`

**Rack access points**

* rack is not navigated “through”, but has access node(s). Picking from a rack uses the nearest access node.

## 3.2 Storage & placement

```yaml
racks:
  - id: R1
    access_node: N10
    levels: 4
    bins_per_level: 20
placement:
  sku_001:
    - {rack: R1, level: 0, bin: 1, qty: 30}
    - {rack: R2, level: 1, bin: 2, qty: 10}
```

## 3.3 Items / SKUs

```yaml
skus:
  - id: sku_001
    unit_pick_time_s: 4
```

## 3.4 Order generation (distribution)

Orders are generated by stochastic processes.

```yaml
orders:
  arrival_process:
    type: poisson
    rate_per_min: 3.2
  lines_per_order:
    type: negbin
    mean: 2.4
    dispersion: 1.2
  sku_popularity:
    type: zipf
    alpha: 1.1
  due_times:
    type: fixed_offset
    minutes: 45
  station_assignment:
    type: least_queue  # or fixed, round_robin
```

## 3.5 Putaway/replen generation (“order puts”)

```yaml
putaway:
  arrival_process:
    type: poisson
    rate_per_min: 0.8
  source_nodes: [INBOUND_1, INBOUND_2]
  destination_policy:
    type: nearest_empty_bin
  priority:
    type: mixed
    p_high: 0.2
```

Replen trigger options:

* threshold-based: when pick-face qty < X
* periodic: every N minutes
* event-based: after large order drawdown

## 3.6 Robots and stations

```yaml
robots:
  count: 25
  max_speed_mps: 1.5
  battery:
    capacity_wh: 400
    min_soc: 0.15
    charge_rate_w: 200
stations:
  - id: P1
    node: STN_P1
    type: pick
    concurrency: 2
    service_time_s:
      base: 15
      per_item: 4
```

---

# 4. Simulation Engine

## 4.1 Time model

Use **discrete-event simulation (DES)** with a small helper tick for motion.

* Events: order arrival, putaway arrival, task assigned, robot enters edge, robot arrives node, station service start/end, inventory decrement, battery threshold, charger start/end.
* Motion is simulated as **edge-traversal events**:

  * compute travel time = edge_length / speed (+ congestion delay policy)
  * schedule arrival event at `t + travel_time`

This avoids per-millisecond stepping and scales well.

## 4.2 Concurrency & collisions (MVP)

Start with **edge capacity** and **node capacity** constraints:

* Each edge has `capacity` (default 1 robot at a time per direction)
* Each node can have `capacity` (default 1) for intersections if you want stricter traffic

Conflict handling policies (pluggable):

* `wait_at_node`: robot waits until edge free
* `reroute_on_wait`: if wait exceeds threshold, recompute route
* `reservation`: reserve edges ahead within window (later)

**MVP choice:** `wait_at_node` + reroute after long waits.

## 4.3 Routing

* Precompute shortest paths (Dijkstra) from all station/rack nodes if graph small; otherwise compute on-demand with caching.
* Cost = length + optional congestion penalty (dynamic).

---

# 5. Dispatching (Optimization Surface)

Make policies explicit modules so you can compare.

## 5.1 Task allocation policies

* `nearest_robot`: choose robot with min ETA to pickup
* `auction`: robots bid = ETA + queue penalty + battery penalty
* `workload_balanced`: min (ETA + λ * tasks_in_queue)

## 5.2 Order batching policies

* `no_batch`: each order line becomes independent task
* `station_batch`: batch tasks going to same station up to K items/tote
* `zone_batch`: batch picks in same zone to reduce travel

## 5.3 Station scheduling policies

* `least_queue`
* `fastest_service_rate`
* `priority_by_due_time`

## 5.4 Putaway vs pick priority

* strict priority tiers (pick > replen > putaway)
* weighted fair queue

---

# 6. Inventory Model

MVP: treat inventory as counts at slots.

Events:

* pick decrements qty
* putaway increments qty
* if qty insufficient, order line becomes `backorder` or triggers replen (config)

Replen strategy:

* “reserve storage” is just another set of racks/slots

---

# 7. Outputs (What Simulator Produces)

## 7.1 KPIs

* Orders completed/hour (throughput)
* Average / p95 order cycle time
* Robot utilization (moving, waiting, servicing, charging)
* Station utilization & queue lengths
* Congestion: avg wait per edge/node, top 10 hotspots
* SLA miss rate (late orders)

## 7.2 Logs

* Event log (append-only): CSV/JSONL
* Robot traces: timestamped position + state
* Station queue traces

## 7.3 Scenario summary report

* config hash
* run seed(s)
* headline metrics table

---

# 8. Architecture (Implementation-Oriented)

## Modules

* `map`: load graph, routing
* `inventory`: sku/slot quantities, reservation
* `orders`: generators (poisson, etc.)
* `tasks`: job decomposition into actions
* `dispatcher`: policy interfaces
* `traffic`: edge/node capacity + conflict rules
* `sim`: DES kernel (priority queue of events)
* `metrics`: aggregation + exporters

## Key interfaces

```text
Policy(TaskAllocation) -> robot_id
Policy(StationAssignment) -> station_id
Policy(Batching) -> list<task_bundle>
TrafficManager -> may_enter_edge(robot, edge, t) bool / next_available_time
```

---

# 9. Minimal Deliverable (v0)

**v0 must do these end-to-end:**

1. Load graph map
2. Generate orders with SKU distribution
3. Convert order lines into pick tasks (pickup at rack access node, deliver to pick station)
4. Assign tasks to robots (nearest ETA baseline)
5. Route robots and enforce edge capacity collisions
6. Station queue service modeling
7. Collect KPI outputs + logs

**Nice-to-have but not required in v0:**

* battery + charging
* multi-level pick times by level
* replen/putaway jobs

---

# 10. v1 Extensions (High value next)

* Add putaway + replen flows (your “order puts”)
* Add battery + charger nodes
* Add reservation-based traffic (windowed)
* Add batching policies and compare
* Add layout experiments (one-way edges, fast lanes)

---

# 11. Example `scenario.yaml` Skeleton

```yaml
seed: 42
duration_minutes: 480

map_file: "map.json"
storage_file: "storage.yaml"

robots:
  count: 30
  max_speed_mps: 1.6

stations:
  - id: P1
    node: STN_P1
    type: pick
    concurrency: 2
    service_time_s: { base: 12, per_item: 3 }

orders:
  arrival_process: { type: poisson, rate_per_min: 4.0 }
  lines_per_order: { type: negbin, mean: 2.2, dispersion: 1.3 }
  sku_popularity: { type: zipf, alpha: 1.05 }
  due_times: { type: fixed_offset, minutes: 60 }

policies:
  task_allocation: { type: nearest_robot }
  station_assignment: { type: least_queue }
  batching: { type: station_batch, max_items: 10 }

traffic:
  edge_capacity_default: 1
  reroute_after_s: 20
```

---

If you want to go straight into “build mode”, I can also give you:

* a **Rust crate layout** (DES priority queue, config parsing, policy traits)
* the **exact event types** + state transitions
* the **metrics schema** (so outputs are stable from day one)

But even before code: do you want the map represented as a **graph** (recommended) or a **grid** (easier to visualize)? I can proceed with graph as the default either way.

